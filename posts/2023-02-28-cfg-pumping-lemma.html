<p>This post is meant to complement the chapter on pumping lemma for context free grammars in the textbook, but not to replace it. You should read this first to keep the relevant example in mind when you read the formal proof from the textbook. <!--more--></p>
<h2 id="the-main-idea">The main idea</h2>
<p>As an example, we will consider the following context free grammar and the string <span class="math inline"><span class="math inline">\(acegfdb\)</span></span> (that belongs to the language generated by the grammar):</p>
<p><span class="math display"><span class="math display">\[A \to aRb\]</span></span> <span class="math display"><span class="math display">\[R \to cBd \ |\ g\]</span></span> <span class="math display"><span class="math display">\[B \to eRf\]</span></span></p>
<p>In the following derivation, <span class="math inline"><span class="math inline">\(R\)</span></span> plays a special role: it generates a sub-string, <span class="math inline"><span class="math inline">\(ceRfd\)</span></span>, which also contains <span class="math inline"><span class="math inline">\(R\)</span></span>. This second <span class="math inline"><span class="math inline">\(R\)</span></span> is used to generate the final terminals, which in this case is just <span class="math inline"><span class="math inline">\(g\)</span></span>.</p>
<p><span class="math display"><span class="math display">\[A \Longrightarrow a\mathbf{R}b \Longrightarrow acBdb \Longrightarrow a\mathbf{ceRfd}b \Longrightarrow acegfdb\]</span></span></p>
<p>Before leading to the terminals, we could have instead repeated the generation of <span class="math inline"><span class="math inline">\(ceRfd\)</span></span> as many times as we wish:</p>
<p><span class="math display"><span class="math display">\[A \Longrightarrow aRb \Longrightarrow acBdb \Longrightarrow aceRfdb \Longrightarrow a(ce)^2R(fd)^2b \ldots \Longrightarrow a(ce)^nR(fd)^nb\]</span></span></p>
<p>before finally using <span class="math inline"><span class="math inline">\(R\)</span></span> to lead to the terminal</p>
<p><span class="math display"><span class="math display">\[\Longrightarrow a(ce)^ng(fd)^nb\]</span></span></p>
<p>So <span class="math inline"><span class="math inline">\(a(ce)^2g(fd)^2b\)</span></span>, <span class="math inline"><span class="math inline">\(a(ce)^3g(fd)^3b\)</span></span>, etc are also in our language:</p>
<p>In fact, we could have skipped the steps shown in bold</p>
<p><span class="math display"><span class="math display">\[A \Longrightarrow aRb \mathbf{\Longrightarrow acBdb \Longrightarrow aceRfdb \Longrightarrow acegfdb}\]</span></span></p>
<p>and directly proceeded to</p>
<p><span class="math display"><span class="math display">\[A \Longrightarrow a\mathbf{R}b \Longrightarrow agb\]</span></span></p>
<p>It is now easy to generalize these observations:</p>
<p>If a string <span class="math inline"><span class="math inline">\(s\)</span></span> is generated in a series of steps that look like this:</p>
<p><span class="math display"><span class="math display">\[S\ldots  \Longrightarrow\ldots  x_1 R x_2 \ldots \Longrightarrow \ldots x_1 \mathbf{y_1Ry_2} x_2 \ldots \Longrightarrow \ldots  x_1 y_1\mathbf{z}y_2 x_2=s\]</span></span></p>
<p>and where both the substrings highlighted in bold are generated by the previous <span class="math inline"><span class="math inline">\(R\)</span></span>, then <span class="math inline"><span class="math inline">\(s\)</span></span> can be realized as a concatenation of 5 substrings as <span class="math inline"><span class="math inline">\(s = x_1 y_1zy_2 x_2\)</span></span>, so that the first <span class="math inline"><span class="math inline">\(R\)</span></span> is responsible for <span class="math inline"><span class="math inline">\(y_1zy_2\)</span></span> within which the second <span class="math inline"><span class="math inline">\(R\)</span></span> is responsible for the substring, <span class="math inline"><span class="math inline">\(z\)</span></span>. In that case, the language must also contain the strings <span class="math inline"><span class="math inline">\(x_1 y_1^nzy_2^n x_2\)</span></span> for each <span class="math inline"><span class="math inline">\(n=0, 1, \ldots\)</span></span></p>
<p>In fact, if the string <span class="math inline"><span class="math inline">\(s\)</span></span> is “long enough”, that will always happen! We can see that by examining the parse tree of a string. <span class="math inline"><span class="math inline">\(R\)</span></span> would have the required property if it occurred twice in one path of the parse tree. That in turn is ensured if the length of the path exceeds the number of variables (pigeon-hole principle!). What is long enough? The precise number is not really important. What is important is that there is such a number.</p>
<h2 id="the-statement">The statement</h2>
<p>Given a context free grammar generating a language <span class="math inline"><span class="math inline">\(L\)</span></span>, there is a number <span class="math inline"><span class="math inline">\(N\)</span></span> called the pumping length, such that, whenever the length of a string <span class="math inline"><span class="math inline">\(s\)</span></span> exceeds <span class="math inline"><span class="math inline">\(N\)</span></span>, it can be broken up as, <span class="math inline"><span class="math inline">\(s = x_1 y_1zy_2 x_2\)</span></span>, so that the strings <span class="math inline"><span class="math inline">\(x_1 y_1^nzy_2^n x_2\)</span></span> also belong to <span class="math inline"><span class="math inline">\(L\)</span></span> for each <span class="math inline"><span class="math inline">\(n=0, 1, \ldots\)</span></span>. We can make no assumptions on where the break up occurs, except for the fact that both <span class="math inline"><span class="math inline">\(y_1\)</span></span> and <span class="math inline"><span class="math inline">\(y_2\)</span></span> cannot be empty (if they could, the lemma willl be useless!), and that the substring <span class="math inline"><span class="math inline">\(y_1zy_2\)</span></span> has length less than <span class="math inline"><span class="math inline">\(N\)</span></span>.</p>
<p>As in the previous pumping lemma, you apply it by using some foresight to find, for each possible pumping length, a string of bigger length that belong to the language. You then show that for each such string, no matter how you break it up as <span class="math inline"><span class="math inline">\(x_1 y_1zy_2 x_2\)</span></span>, at least for some <span class="math inline"><span class="math inline">\(n\)</span></span>, <span class="math inline"><span class="math inline">\(x_1 y_1^nzy_2^n x_2\)</span></span> does not belong the language.</p>
<h2 id="example">Example</h2>
<p>The language over the alphabet, <span class="math inline"><span class="math inline">\(\Sigma=\{a, b, c\}\)</span></span>, consisting of strings of the form <span class="math inline"><span class="math inline">\(a^nb^nc^n\)</span></span> cannot be context free. To see this, observe that if the pumping length is <span class="math inline"><span class="math inline">\(N\)</span></span>, then <span class="math inline"><span class="math inline">\(a^Nb^Nc^N\)</span></span> exceeds that length. If the language were context free, then there is some unknown way to break it up as <span class="math inline"><span class="math inline">\(x_1 y_1zy_2 x_2\)</span></span> so that <span class="math inline"><span class="math inline">\(x_1 y_1^nzy_2^n x_2\)</span></span> belongs to the language for every <span class="math inline"><span class="math inline">\(n\)</span></span>. Notice that if either <span class="math inline"><span class="math inline">\(y_1\)</span></span> or <span class="math inline"><span class="math inline">\(y_2\)</span></span> contains repetitions of more than one character, then its power will have at least some characters out of order (eg. <span class="math inline"><span class="math inline">\((aabb)^2 = aabbaabb\)</span></span> has some <span class="math inline"><span class="math inline">\(a\)</span></span>’s following <span class="math inline"><span class="math inline">\(b\)</span></span>’s). So we only need to bother about the case where both contain repetitions of only one character. In that case <span class="math inline"><span class="math inline">\(x_1 y_1^nzy_2^n x_2\)</span></span> will increase the powers of at most two characters whlie leaving the third untouched, therefore such a string cannot belong to the language where all three powers are required to be the same. :::</p>