<ol>
<li><p>If <span class="math inline">\(L_1\)</span> and <span class="math inline">\(L_2\)</span> are both regular languages over an alphabet <span class="math inline">\(\Sigma\)</span>. If <span class="math inline">\(L_1\)</span> can be recognized by a finite state automaton <span class="math inline">\(A_1\)</span> and <span class="math inline">\(L_2\)</span> can be recognized by a finite state automaton <span class="math inline">\(A_2\)</span>, then show that one can use <span class="math inline">\(A_1\)</span> and <span class="math inline">\(A_2\)</span> to design a *non-deterministic* finite state automaton that recognizes,</p>
<ol>
<li><p><span class="math inline">\(L_1 \cup L_2\)</span></p></li>
<li><p><span class="math inline">\(L_1 \circ L_2 = \{s_1s_2 \ |\ s_1 \in L_1, s_2 \in L_2\}\)</span>, i.e., it is obtained by concatenating each string in <span class="math inline">\(L_1\)</span> with a string in <span class="math inline">\(L_2\)</span>.</p></li>
<li><p><span class="math inline">\(L_1^* = \{s_1s_2\ldots s_n \ |\ s_i \in L_1\}\)</span>.</p></li>
</ol></li>
<li><p>Design a *non*-deterministic finite state automaton over the alphabet <span class="math inline">\(\Sigma={0,1}\)</span> that will accept a string if and only if it</p>
<ol>
<li><p>is the empty string</p></li>
<li><p>is not the empty string</p></li>
<li><p>is precisely the string 111</p></li>
<li><p>begins with the substring 111</p></li>
<li><p>is the empty string or begins with the substring 111</p></li>
<li><p>ends with the substring 111</p></li>
<li><p>begins with 0 and ends with 1</p></li>
<li><p>contains the substring 111</p></li>
</ol></li>
</ol>